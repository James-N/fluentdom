import VNode from '../model/VNode';

import utility from './utility';
import LOG from './log';


class VDOMNodeIterator {
    /**
     * @param {VNode[]} vnodes
     */
    constructor (vnodes) {
        /**
         * @type {VNode[]}
         */
        this._vnodes = vnodes;

        this._index = 0;
        this._subIndex = 0;
    }

    /**
     * get next node
     *
     * @returns {Node?}
     */
    next () {
        var vnode = this._vnodes[this._index];
        var node = vnode.domNode;

        if (Array.isArray(node)) {
            var result = node.length > 0 ? node[this._subIndex] : null;

            this._subIndex++;
            if (this._subIndex >= node.length) {
                this._subIndex = 0;
                this._index++;
            }

            return result;
        } else {
            this._index++;
            this._subIndex = 0;
            return node;
        }
    }

    /**
     * check iterator ended
     *
     * @returns {Boolean}
     */
    isEnd () {
        return this._index >= this._vnodes.length;
    }
}

const NODE_SEARCH_WINDOW_SIZE = 3;

/**
 * refresh contents of given dom element by vnodes
 *
 * @param {Element|DocumentFragment} elm  the dom node that contains nodes generated by vnodes
 * @param {VNode[]} vnodes  list of vnodes
 */
export function rearrangeElementChildNodes (elm, vnodes) {
    var nodeList = elm.childNodes;
    var node = nodeList.length > 0 ? nodeList[0] : null;

    var vnodeIter = new VDOMNodeIterator(vnodes);
    while (!vnodeIter.isEnd() && node !== null) {
        let dnode = vnodeIter.next();
        if (dnode !== null) {
            if (dnode === node) {
                node = node.nextSibling;
            } else {
                let nnode = node.nextSibling;
                let found = false;
                for (let i = 0; i < NODE_SEARCH_WINDOW_SIZE && !found && nnode !== null; i++, nnode = nnode.nextSibling) {
                    if (nnode == dnode) {
                        found = true;
                    }
                }

                if (found) {
                    while (node !== dnode) {
                        node = node.nextSibling;
                        elm.removeChild(node.previousSibling);
                    }
                    node = node.nextSibling;
                } else {
                    elm.insertBefore(dnode, node);
                }
            }
        }
    }

    if (vnodeIter.isEnd()) {
        if (node !== null) {
            do {
                let temp = node;
                node = node.nextSibling;
                elm.removeChild(temp);
            } while (node !== null);
        }
    } else {
        while (!vnodeIter.isEnd()) {
            let dnode = vnodeIter.next();
            if (dnode !== null) {
                elm.appendChild(dnode);
            }
        }
    }
}

/**
 * extract dom nodes generated by all child nodes
 *
 * @param {VNode} vnode
 * @returns {Node|Node[]}
 */
export function collectChildDOMNodes(vnode) {
    var childCount = vnode.children.length;
    if (childCount === 0) {
        return null;
    } else if (childCount === 1) {
        return vnode.children[0].domNode;
    } else {
        var domNodes = [];

        vnode.children.forEach(c => {
            if (Array.isArray(c.domNode)) {
                c.domNode.forEach(n => domNodes.push(n));
            } else {
                domNodes.push(c.domNode);
            }
        });

        return domNodes;
    }
}


/**
 * tree walk methods
 */
const WALK_METHOD = {
    DFS: 1,
    BFS: 2
};

/**
 * node tree walker
 */
class NodeTreeWalker {
    /**
     * @param {VNode} node      the node to start traversal
     * @param {Number} method   the traverse method
     * @param {(function(VNode):Boolean|Boolean[])=} filter    custom filter
     */
    constructor (node, method, filter) {
        this._queue = [node];
        this._method = method;
        this._filter = filter;

        this._currentNode = null;
    }

    _checkNode (node) {
        if (this._filter) {
            var result = this._filter.call(null, node);
            if (Array.isArray(result)) {
                return result;
            } else {
                return [!!result, !!result];
            }
        } else {
            return [true, true];
        }
    }

    /**
     * @return {VNode?}
     */
    next () {
        while (this._queue.length > 0) {
            var node = this._queue.shift();
            var [acceptNode, acceptChildren] = this._checkNode(node);

            if (acceptChildren) {
                var children = node.children;
                if (children.length > 0) {
                    if (this._method == WALK_METHOD.DFS) {
                        for (let i = children.length - 1; i >= 0; i--) {
                            this._queue.unshift(children[i]);
                        }
                    } else {
                        for (let child of children) {
                            this._queue.push(child);
                        }
                    }
                }
            }

            if (acceptNode) {
                this._currentNode = node;
                return node;
            }
        }

        this._currentNode = null;
        return null;
    }

    current () {
        return this._currentNode;
    }

    /**
     * @return {Boolean}
     */
    isEnd () {
        return this._queue.length === 0;
    }
}

NodeTreeWalker.WALK_METHOD = WALK_METHOD;

/**
 * get an iterator that traverse the given node and its children
 *
 * @param {VNode} node  node on which to start iteration
 * @param {Boolean=} dfs  whether traverse the tree by depth first order
 * @param {(function(VNode):Boolean|Boolean[])=} filter    custom filter
 *
 * @returns {NodeTreeWalker}
 */
export function getNodeIter (node, dfs = false, filter = null) {
    if (utility.isNullOrUndef(node)) {
        throw new Error("node is null");
    }

    if (!(node instanceof VNode)) {
        throw new TypeError("node must be instance of VNode");
    }

    return new NodeTreeWalker(node, dfs ? WALK_METHOD.DFS : WALK_METHOD.BFS, filter);
}

/**
 * destroy all nodes
 *
 * @param {VNode[]} nodes
 */
export function destroyNodes (nodes) {
    nodes.forEach(n => {
        try {
            n.destroy();
        } catch (err) {
            LOG.error("error when destroying node", err);
        }
    });
}

/**
 * check whether the given needs to be recomputed
 *
 * @param {VNode} node
 * @returns {Boolean}
 */
export function needCompute (node) {
    return !node.lazy || node.flags.dirty;
}